# 算法(Algorithm)通俗定义:
- 解决问题的办法/步骤逻辑


# 数组(线性)

- 缺点:插入,删除性能低,难于存放不同类型,扩容操作耗时
- 优点: 查找快

# 栈(线性)

- 对数组的任意性加以限制,受限的线性结构
- 栈底,压栈(栈顶上面添加元素,成为栈顶),出栈(先邻元素成为栈顶),栈顶(只能该端删除操作)
- 后进先出
- 举例
    1. 自助餐餐盘
    2. 邮件
    3. 函数调用栈(a->b->c-<d(栈顶)), 递归有时候会导致栈溢出.

- 实现栈结构方式
 1. 基于数组
 2. 基于链表

# 队列(线性)

- 先进先出(FIFO FIRST IN FIRST OUT)
- 后端添加元素, 前端删除元素

## 应用
1. 打印队列
2. 线程队列

# 链表

- 高效的插入,删除操作
- 查询速度慢

- 缺点: 返回上一个节点很难

## 操作
- append(element): 列表尾部添加一个新的一项
- insert(position,element): 指定位置插入一个新的项
- get(position) :获取对应位置的元素
- indexOf(element) 返回元素在列表的索引,没有返回-1
- update(position,element) :修改某个位置的元素
- removeAt(position) : 从列表的特定位置移除一项
- remove(element): 列表移除一项

- isEmpty() : 是否为空
- size() : 个数

# 双向链表
- 插入,删除复杂

# 集合

- 通常实现采用hash表
- 元素不可以重复
- 元素无序
- 不能通过下标进行访问
 ## 操作
 - add(value)
 - remove(value)
 - has(value)
 - clear()
 - size()
 - values()


# 字典
- key-values
- key不允许重复,values可以重复

# 哈希表
- 数组进行插入操作,效率比较低
- 数组查找基于索引效率高
- 数组删除操作效率也不高
- 哈希表比树查找还快

- 哈希表就是为了解决数组存在的这些问题(o(1)的插入,删除操作)

## 缺点
- 数据没有顺序
- 哈希表的key不可重复
- 空间利用率不高
- 不能快速找到最大或者最小值
- 结构就是数组, 针对下标值的变换, 通过哈希函数来转换->hashCode

## 字母转数字的方案
1. 字符编码
-  IOS, GBK, Asscicode, Unicode(utf-8,utf-16,utf-32)- 

- 方案一: 数字相加
1. 单词每个字符的编码求和(缺点很多单词最终下标可能都是同一个数)

- 方案二: 幂的连乘(基本保证它的唯一性)
2. 7654 = 7*10^3 + 6*10^2 + 5*10 + 4
- 缺点:字符大的话会造成超过计算机的内存
- 空间浪费

3. 为了解决方案二的问题,哈希化函数就出现了

## 认识哈希化
- 一种压缩方法,把幂的连乘方案系统得到的巨大值压缩到可接受的数组范围
### 如何压缩

- 取余操作符,作用是得到一个数被另外一个整数整除的后的余数(还是存在相同)

### 哈希化
- 大数字转成数组范围内小标的过程

### 哈希函数
- 通常我们会将单词转成大数字,大数字进行哈希化的代码放在一个函数里面,这个函数就是哈希函数

### 哈希表
- 最终将数据插入到这个数组,对整个结构的封装,称之为哈希表

### 存在问题:
1. 我们在100000数组中,放50000单词已经足够
2. 哈希化的下标值依然会重复,如何解决?

#### 常见两种解决方案
1. 链地址法(拉链法)
- 每一个位置存储的是一个链表或者数组, 然后在链表(推荐)或者数组存储数据
2. 开发地址法
- 寻找空白的单元格来添加重复的数据
- 新插入的数据应该放在index,但是index已经有数据了
- 发现有其余位置还是没有任何内容的
- 这时候可以寻找对应的空白位置来存放这个数据
    1. 如何寻找空白单元格位置呢?
        - 线性探测
            - index位置+1,开始一点点查找直至找到空白位置
            - 首先哈希化得到index, 从index+1开始查找到空位置(因为如果有空位置有相同就必须添加进去)看是否有与我们要查找的值一致,有的化就返回(规定删除的时候不能设置为null)
            - 存在问题: 数据聚集(数据聚一起,),影响哈希表性能(查找的时候,需要查找多步)
        - 二次探测
            - 针对步长进行优化,步长平方
        - 再哈希法(推荐)--解决上述两个问题
            - 另外一个函数再进行哈希化,这次的结果作为步长,结果不能为0
            - 再哈希化函数: stepSize = constant -(key % constant)


### 哈希化的效率
1. 快速计算
    - 霍纳法则(秦九韶算法): 对多项式的优化
2. 均匀分布
    - 质数的使用
        1. 哈希表长度
        2. N次幂的底数



# 树
- 空树
- 根
- 子树
## 术语
1. 节点的度: 节点的子树个数
2. 树的度: 所有节点最大的度数
3. 叶子节点: 没有子树
4. 父节点
5. 子节点
6. 兄弟节点
7. 路径和路径长度(边的个数)
8. 节点层次
9. 树的深度

## 二叉树(重要)
- 每个节点最多只有两个子节点
- 第i层最大节点数: 2^(i-1);i>=1
- 深度为k的二叉树有最大节点数2^k -1;k>=1
- 对任何非空二叉树,n0表示叶节点的个数,n2是度为2的非叶子节点,则n0=n2+1
### 存储
1. 数组(不合适): 造成空间浪费
2. 链表(推荐) : 左节点,右节点,数据

### 二叉搜索树(BST)
- Binary Search Tree
- 非空左子树的所有键值小于其根节点的键值
- 非空右子树的所有键值大于其根节点的键值
- 左,右节点都是二叉树
#### 优点
- 二分查找思想
- 查找最大次数等于二叉搜索树的深度
- 插入节点的时候,也是类似,一层层比较大小,找到合适的位置
